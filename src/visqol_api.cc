// Copyright 2019 Google LLC, Andrew Hines
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "visqol_api.h"

#include <string>
#include <vector>

// Placeholder for runfiles.
#include "absl/status/statusor.h"
#include "absl/types/span.h"
#include "commandline_parser.h"
#include "similarity_result.h"
#include "src/proto/similarity_result.pb.h"  // Generated by cc_proto_library rule
#include "src/proto/visqol_config.pb.h"  // Generated by cc_proto_library rule
#include "status_macros.h"
#include "visqol_manager.h"

namespace Visqol {

const size_t VisqolApi::k48kSampleRate = 48000;

absl::Status VisqolApi::Create(const VisqolConfig config) {
  // If audio info was not supplied, return error.
  if (!config.has_audio()) {
    return absl::Status(absl::StatusCode::kInvalidArgument,
                        "Audio info must be supplied for config.");
  }

  // Read the sample rate for the input signals.
  // The sample rate must be the same for both signals.
  auto audio_info = config.audio();
  sample_rate_ = audio_info.sample_rate();

  // Ensure a sample rate value was provided.
  if (sample_rate_ == 0) {
    return absl::Status(absl::StatusCode::kInvalidArgument,
                        "The sample rate for the signals must be set.");
  }

  // Read the config options if they were set. Else, use default values.
  bool speech_mode = false;
  bool unscaled_speech_map = false;
  bool allow_sr_override = false;
  int search_window = 60;
  bool use_lattice_model = true;

  std::string model_file;
  if (config.has_options()) {
    auto config_options = config.options();
    speech_mode = config_options.use_speech_scoring();
    unscaled_speech_map = config_options.use_unscaled_speech_mos_mapping();
    allow_sr_override = config_options.allow_unsupported_sample_rates();
    use_lattice_model = config_options.use_lattice_model();
    model_file = config_options.svr_model_path();
    if (config_options.search_window_radius()) {
      search_window = config_options.search_window_radius();
    }
  }

  if (model_file.empty()) {
    model_file = speech_mode ? kDefaultSpeechModelFile : kDefaultAudioModelFile;
    model_file = FilePath::currentWorkingDir() + model_file;
  }

  // ViSQOL Audio currently supports 48k sample rates only.
  //
  // TODO We also will support speech mode which should support other sample
  // rates, so we should allow some flexibility to handle that. Speech mode
  // supports non-48k by explicitly setting the equivalent rectangular bands to
  // specific frequencies (the bands are independent of sample rate, unlike how
  // visqolaudio works). It seems like if we did this for Visqol we could
  // support arbitrary sample rates.
  if (sample_rate_ != k48kSampleRate && speech_mode == false &&
      allow_sr_override == false) {
    return absl::Status(
        absl::StatusCode::kInvalidArgument,
        "Currently, 48k is the only sample rate supported by ViSQOL Audio. "
        "See README for details of overriding.");
  }

  // Initialize ViSQOL with the model file.
  VISQOL_RETURN_IF_ERROR(visqol_.Init(FilePath(model_file), speech_mode,
                                      unscaled_speech_map, search_window,
                                      use_lattice_model));

  return absl::Status();
}

absl::StatusOr<SimilarityResultMsg> VisqolApi::Measure(
    const absl::Span<double>& reference, const absl::Span<double>& degraded) {
  // Initialize the audio signals and perform comparison.
  AudioSignal ref_sig{reference, sample_rate_};
  AudioSignal deg_sig{degraded, sample_rate_};
  SimilarityResultMsg sim_result_msg;
  VISQOL_ASSIGN_OR_RETURN(sim_result_msg, visqol_.Run(ref_sig, deg_sig));

  return sim_result_msg;
}

}  // namespace Visqol
